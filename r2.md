
socket 消息监测:


消息:`request_judge`请求测评测,请求数据如下:

```
{
    "code":String,代码
    "lang":String,代码语言:c,cpp,pascal,python
    "time":int 时间 //second
    "memory":int 内存 //mb
    "stack":int 栈大小 //mb
    "output_size":输出大小 //mb
    "judge_id":请求评测的文件id,/judge_server/data 目录下
    "cmp": String, 文件比较器,fcmp2 ,或者是spj,如果是spj,就在data/jduge_id/目录下录找spj.cpp,或者spj.py?
    "judger":String,选择哪个评测机,qjudge,ujudge
    "revert":{ Object ,返回的数据
    }
}
```

## 返回信息


```js
socket.on('judge_respone',function(data){
})
```

```
{
    status:0,
    mid:START_JUDGE/1
}
```

返回信息的mid值
```
PREPARE_JUDGE   0
START_JUDGE     1
AYANALIYSE_DATA 2
COMPILE_COMLETE 3
JUDGING         4
END_JUDGE       5
```

## 生成settings 类

其中`roundsetting`主要是产生各种参数,产生的参数如下

 - `revert` {} 返回的数据
 - `sid`    str socket_client_id
 - `cmp`    str 比较器 / spj.cpp
 - `code`   str 代码
 - `time`    时间
 - `memory`  内存
 - `judge_id` data 目录 下的数据所有的文件夹名
 - `round_id`:一个随机的字符串,`Handler`类初始化时传递过来
 - `data_dir`:和`problem_id`行成的评测数据路径
 - `round_dir`:和`round_id`行成的临时测评路径
 - `language_settings`:`languages.py`里对应的语言设定
 - `src_name`   源码名
 - `exe_name`   程序名
 - `src_path`   源码路径
 - `exe_path`   生成的程序路径
 - `compile_out_path` 编译输出
 - `compile_log_path` 编译的log
 - `compile_cmd`      编译的cmd
 - `seccomp_rule_name` 

## 数据检查

数据目录的数据是否正确
spj.cpp 是否存在

## 编译

## 评测

传递固定的参数,选择不同的评测机

## 结束评测,返回数据


数据类型为:

## 处理流程

生成settings 类

检查源数据文件目录
    - 是否存在
    - 数据命名是否规范
    - 返回相关信息
        - 长度
        - 文件列表 有序 [ [in,out]]

编译源代码 编译spj/复制cmp

评测
    - 文件比较

整体评测结束

## 数据命名规范

输入文件后缀`.in`,`.input`,`.txt`
输出文件后缀`.out`,`.ans`,`.output`
